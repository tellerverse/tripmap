<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>tripmap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="./style.css">
</head>
<body>
<div class="controls options">
  <!-- <div class="function"><button id="">âœˆï¸</button><span>Option 1</span></div> -->
  <div class="function"><button id="myZoomIn">â•</button><span>Zoom In</span></div>
  <div class="function"><button id="myZoomOut">â–</button><span>Zoom Out</span></div>
  <div class="function"><button id="myScreenshot">ğŸ“¸</button><span>Snapshot</span></div>
</div>

<div class="controls pencil">
  <div class="function"><button data-mode="country" class="active">ğŸ–±ï¸</button></div>
  <div class="function"><button data-mode="distance">âœˆï¸</button></div>
  <div class="function"><button data-mode="trip">ğŸ“</button></div>
</div>
<div id="infoPanel">
  <div id="infoName">Click somewher...</div>
  <div id="infoContent">Click on a country to see more information here.</div>
</div>
<div id="infoRest"></div>
<div id="teleportPanel" class="teleport-panel">
  <input id="teleLat" type="number" min="-90" max="90" placeholder="Lat">
  <input id="teleLng" type="number" min="-180" max="180" placeholder="Lon">
  <input id="teleZoom" type="number" min="1" max="19" placeholder="Zoom">
</div>
<div id="map"></div>
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>
<script type="module">
  import { ref, get, set } from "https://www.gstatic.com/firebasejs/10.3.0/firebase-database.js";
  import { db } from "./database.js";
  import { countryCapitals } from "./data.js";
  // import fetch from "node-fetch";
  const map = L.map("map", { zoomControl:false }).setView([20, 0], 3);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom:19, attribution:"Â© OpenStreetMap contributors" }).addTo(map);
  // L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",{attribution: "Â© OpenStreetMap Â© CARTO"}).addTo(map);
  const infoContent = document.getElementById('infoContent');
  const infoName = document.getElementById('infoName');
  const infoRest = document.getElementById('infoRest');

  let comparisonCentroid;
  let sourceLat;
  let comparisonLayer = null;
  let comparisonFeature = null;
  let isDraggingComparison = false;
  let geojsonLayer;
  let selectedCountryPolygon = null;
  let selectedCountryName = null;
  let selectedCountryLayer = null;
  let randomHighlightInterval = null;
  let lastRandomLayer = null;
  const BLINK_INTERVAL_MS = 100;
  const MIN_AREA_KM2 = 3_000_000; // z.B. ~ Australien
  let blinkingLayers = [];
  let allCountriesWithArea = [];
  let activeMode = "country"; // default
  let comparisonBaseFeature = null;   // NIE verÃ¤ndern
  let comparisonOffset = { km: 0, bearing: 0 };
  let comparisonSourceLat = null;
  let comparisonTargetLatLng = null;

  const pencilButtons = document.querySelectorAll(".controls.pencil button");

  pencilButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      // UI
      pencilButtons.forEach(b => b.classList.remove("active"));
      btn.classList.add("active");

      // Mode setzen
      activeMode = btn.dataset.mode;

      // Cleanup
      
      resetModes();
    });
  });

  function resetModes() {
    // Flight cleanup
    measurePoints = [];
    clearMeasurement();
    despawnComparison();
    updateScreenshotButton();
    if (selectedCountryLayer) {
      removeClass(selectedCountryLayer, "country-selected");
      removeClass(selectedCountryLayer, "country-hover");

      selectedCountryLayer = null;
      selectedCountryPolygon = null;
      selectedCountryName = null;

      infoContent.style.display = "none";
      infoName.style.display = "none";
    }

    // Map cursor
    map.getContainer().classList.toggle(
      "flight-mode",
      activeMode === "distance"
    );

    if (activeMode === "country") {
      startAreaBasedBlinking();
    } else {
      stopAreaBasedBlinking();
    }
  }


  map.on("click", (e) => {
    switch (activeMode) {
      case "distance":
        handleDistanceClick(e);
        break;

      case "trip":
        handleTripClick(e);
        break;

      case "country":
      default:
        // LÃ¤nder werden Ã¼ber onEachCountry behandelt
        break;
    }
  });

  map.on("contextmenu", () => {
    if (activeMode === "distance") {
      clearMeasurement(true);
    }
  });
  // function startRandomHighlight() {
  //   randomHighlightInterval = setInterval(() => {
  //     // Nur wenn kein Land ausgewÃ¤hlt ist
  //     if (!selectedCountryLayer && geojsonLayer) {
  //       const layers = geojsonLayer.getLayers();
  //       if (layers.length === 0) return;

  //       // Vorheriges zurÃ¼cksetzen
  //       if (lastRandomLayer && lastRandomLayer !== selectedCountryLayer) {
  //         geojsonLayer.resetStyle(lastRandomLayer);
  //       }

  //       // ZufÃ¤lliges Layer auswÃ¤hlen
  //       const randomIndex = Math.floor(Math.random() * layers.length);
  //       const layer = layers[randomIndex];

  //       // Nur markieren, wenn es nicht gerade ausgewÃ¤hlt ist
  //       if (layer !== selectedCountryLayer) {
  //         layer.setStyle({
  //           color: "#555",
  //           weight: 1,
  //           fillColor: "black",
  //           fillOpacity: 1
  //         });
  //         lastRandomLayer = layer;
  //       }
  //     }
  //   }, 100);
  // }

  function addClass(layer, className) {
    const el = layer.getElement();
    if (el) el.classList.add(className);
  }

  function removeClass(layer, className) {
    const el = layer.getElement();
    if (el) el.classList.remove(className);
  }

  
  let blinkInterval = null;

  function startAreaBasedBlinking() {
    if (blinkInterval) return;

    blinkInterval = setInterval(() => {
      if (activeMode !== "country") return;
      if (selectedCountryLayer) return;

      blinkingLayers.forEach(l => removeClass(l, "country-blink"));
      blinkingLayers = [];

      let totalArea = 0;
      const shuffled = [...allCountriesWithArea].sort(() => Math.random() - 0.5);

      for (const { layer, areaKm2 } of shuffled) {
        addClass(layer, "country-blink");
        blinkingLayers.push(layer);
        totalArea += areaKm2;
        if (totalArea >= MIN_AREA_KM2) break;
      }
    }, BLINK_INTERVAL_MS);
  }

  function stopAreaBasedBlinking() {
    if (!blinkInterval) return;

    clearInterval(blinkInterval);
    blinkInterval = null;

    blinkingLayers.forEach(l => removeClass(l, "country-blink"));
    blinkingLayers = [];
  }



  function onEachCountry(feature, layer) {
    layer.on({
      mouseover: () => {
        if (activeMode !== "country") return;
        if (layer !== selectedCountryLayer) {
          addClass(layer, "country-hover");
        }
      },

      mouseout: () => {
        if (layer !== selectedCountryLayer) {
          removeClass(layer, "country-hover");
        }
      },

      click: () => {
        if (activeMode !== "country") return;
        if (layer === selectedCountryLayer) {
          removeClass(layer, "country-selected");
          selectedCountryLayer = null;
          selectedCountryPolygon = null;
          selectedCountryName = null;
          despawnComparison();
          infoContent.style.display = "none";
          infoName.style.display = "none";
          return;
        }

        if (selectedCountryLayer) {
          removeClass(selectedCountryLayer, "country-selected");
        }

        selectedCountryLayer = layer;
        selectedCountryPolygon = feature.geometry;
        selectedCountryName = feature.properties.ADMIN;
        createComparisonCopy(feature, layer.getBounds().getCenter());

        addClass(layer, "country-selected");
        removeClass(layer, "country-hover");
        for (const blinkLayer of blinkingLayers) {
          removeClass(blinkLayer, "country-blink");
        }
        blinkingLayers = [];
        infoName.textContent = selectedCountryName;
        infoContent.style.display = "flex";
        infoName.style.display = "flex";
        
        fetchAIIntro(selectedCountryName);
        fetchRestCountries(selectedCountryName);

      }
    });
  }

  function createComparisonCopy(feature) {
    comparisonBaseFeature = turf.clone(feature);
    comparisonCentroid = turf.centroid(feature);

    // ğŸ”¥ Startposition = Original-Land
    const [lng, lat] = comparisonCentroid.geometry.coordinates;
    comparisonTargetLatLng = L.latLng(lat, lng);

    renderComparison(comparisonTargetLatLng);
    enableComparisonDragging();
  }


  function renderComparison(targetLatLng) {
    const sourceCenter = comparisonCentroid.geometry.coordinates;
    const sourceLatLng = L.latLng(sourceCenter[1], sourceCenter[0]);

    const p0 = project(sourceLatLng);
    const p1 = project(targetLatLng);

    const scale =
      Math.cos(sourceLatLng.lat * Math.PI / 180) /
      Math.cos(targetLatLng.lat * Math.PI / 180);

    const dx = p1.x - p0.x;
    const dy = p1.y - p0.y;

    const moved = turf.clone(comparisonBaseFeature);

    turf.coordEach(moved, coord => {
      const latlng = L.latLng(coord[1], coord[0]);
      const p = project(latlng);

      const scaled = L.point(
        p0.x + (p.x - p0.x) * scale + dx,
        p0.y + (p.y - p0.y) * scale + dy
      );

      const ll = unproject(scaled);
      coord[0] = ll.lng;
      coord[1] = ll.lat;
    });

    if (comparisonLayer) map.removeLayer(comparisonLayer);
    comparisonLayer = L.geoJSON(moved, {
      className: "country comparison",
      style: {
        color: "#00ffff",
        weight: 2,
        fillOpacity: 0.15
      }
    }).addTo(map);
    comparisonLayer.on("mousedown", e => {
      L.DomEvent.stopPropagation(e);
      L.DomEvent.preventDefault(e);

      isDraggingComparison = true;
      map.dragging.disable();
    });
  }


  function project(latlng) {
    return map.options.crs.project(latlng);
  }

  function unproject(point) {
    return map.options.crs.unproject(point);
  }


  function scaleLongitude(feature, centroid, scaleX) {
    const [cx, cy] = centroid.geometry.coordinates;

    const clone = turf.clone(feature);

    turf.coordEach(clone, coord => {
      coord[0] = cx + (coord[0] - cx) * scaleX;
    });

    return clone;
  }


  function moveAndScaleCoords(coords, centerPoint, dx, dy, scale) {
    if (typeof coords[0] === "number") {
      const p = map.latLngToLayerPoint([coords[1], coords[0]]);

      const scaled = L.point(
        centerPoint.x + (p.x - centerPoint.x) * scale + dx,
        centerPoint.y + (p.y - centerPoint.y) * scale + dy
      );

      const ll = map.layerPointToLatLng(scaled);
      return [ll.lng, ll.lat];
    }
    return coords.map(c =>
      moveAndScaleCoords(c, centerPoint, dx, dy, scale)
    );
  }

  function despawnComparison() {
    if (comparisonLayer) {
      map.removeLayer(comparisonLayer);
      comparisonLayer = null;
    }

    comparisonBaseFeature = null;
    comparisonCentroid = null;
    comparisonTargetLatLng = null;
    isDraggingComparison = false;

    map.dragging.enable();
  }

  function translateToLatLng(feature, targetLatLng) {
    const centroid = turf.centroid(feature).geometry.coordinates;

    const from = turf.point(centroid);
    const to = turf.point([targetLatLng.lng, targetLatLng.lat]);

    const distanceKm = turf.distance(from, to, { units: "kilometers" });
    const bearing = turf.bearing(from, to);

    return turf.transformTranslate(feature, distanceKm, bearing, {
      units: "kilometers"
    });
  }

  function enableComparisonDragging() {
    if (!comparisonLayer) return;

    map.on("mousedown", e => {
      if (isDraggingComparison) {
        L.DomEvent.stopPropagation(e);
        map.dragging.disable();
      }
    });

    map.on("mousemove", e => {
      if (!isDraggingComparison || !comparisonBaseFeature) return;

      comparisonTargetLatLng = e.latlng;
      renderComparison(comparisonTargetLatLng);
    });

    map.on("mouseup", () => {
      isDraggingComparison = false;
      map.dragging.enable();
      // ğŸ¯ Zielposition bleibt gespeichert
    });
  }

  fetch("https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_10m_admin_0_countries.geojson")
  .then(res => res.json())
  .then(data => {
    geojsonLayer = L.geoJSON(data, {
      className: "country",
      onEachFeature: onEachCountry
    }).addTo(map);

    // FlÃ¤che einmal berechnen
    geojsonLayer.eachLayer(layer => {
      const feature = layer.feature;
      const areaKm2 = turf.area(feature) / 1_000_000;
      allCountriesWithArea.push({ layer, areaKm2 });
    });

    startAreaBasedBlinking();
  });

  async function fetchAIIntro(countryName) {
    const res = await fetch("/api/getIntro", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ countryName })
    });

    if (!res.ok) {
      infoContent.textContent = "AI unavailable, loading wikipediaâ€¦";
      setTimeout(() => {
        fetchWikiIntro(countryName);
      }, 2000);
      return;
    }

    const data = await res.json();
    infoContent.textContent = data.text;
  }

  
  const countryToWiki = {
    Germany: "Germany",
    France: "France",
    Spain: "Spain"
  };

  async function fetchWikiIntro(countryName) {
    infoContent.textContent = `AI unavailable, loading wikipediaâ€¦`;
    try {
      const wikiTitle = countryToWiki[countryName] || countryName;
      const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(wikiTitle)}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error("Wikipedia-Eintrag nicht gefunden.");
      const data = await res.json();
      infoContent.textContent = data.extract || "Keine Informationen verfÃ¼gbar.";
    } catch(e) {
      infoContent.textContent = `Fehler beim Laden von ${countryName}.`;
      console.error(e);
    }
  }

  async function fetchRestCountries(countryName) {
    infoContent.innerHTML = "Loading country dataâ€¦";

    const res = await fetch(
      `https://restcountries.com/v3.1/name/${encodeURIComponent(countryName)}?fullText=true`
    );

    if (!res.ok) {
      // infoContent.textContent = "No country data found.";
      return;
    }

    const [country] = await res.json();

    renderCountryAttributes(country);
  }

  function renderCountryAttributes(country) {
    // infoContent.innerHTML = "";
    const keysIWant = [
      "population",
      "timezones",
      "flag",
      "languages",
      "capital",
      "currencies"
    ];
    let i = 0;
    for (const [key, value] of Object.entries(country)) {
      // if (i++ >= 3) break;
      if (!keysIWant.includes(key)) continue;
      const content = document.createElement("div");
      content.classList.add("restInfoTile", "scroll-text");
      content.textContent = formatValue(value);
      infoRest.appendChild(content);
    }
  }

  function formatValue(value) {
    if (value == null) return "â€”";

    if (Array.isArray(value)) {
      return value.map(v => formatValue(v)).join(", ");
    }

    if (typeof value === "object") {
      return Object.values(value)
        .map(v => formatValue(v))
        .join(", ");
    }

    return value.toString();
  }


  // Zoom Buttons
  document.getElementById("myZoomIn").addEventListener("click", () => map.zoomIn());
  document.getElementById("myZoomOut").addEventListener("click", () => map.zoomOut());

  let flightMode = false;
  let measurePoints = [];
  let measureLayer = null;
  let measureLabels = [];
  let measureHandles = [];

  function handleDistanceClick(e) {
    measurePoints.push(e.latlng);
    createHandle(e.latlng, measurePoints.length - 1);
    redrawMeasurement();
  }

  function redrawMeasurement() {
    clearMeasurement(false);

    if (measurePoints.length < 2) return;

    if (measurePoints.length === 2) {
      measureLayer = L.polyline(measurePoints, {
        color: "white",
        weight: 2
      }).addTo(map);

      addEdgeLabels(measurePoints);
    } else {
      measureLayer = L.polygon(measurePoints, {
        color: "white",
        fillOpacity: 0.2
      }).addTo(map);

      addEdgeLabels(measurePoints, true);
      addAreaLabel(measurePoints);
    }
  }


  function addEdgeLabels(points, closed = false) {
    const pts = closed ? [...points, points[0]] : points;

    for (let i = 0; i < pts.length - 1; i++) {
      const a = pts[i];
      const b = pts[i + 1];

      const len = turf.distance(
        [a.lng, a.lat],
        [b.lng, b.lat],
        { units: "kilometers" }
      );

      const mid = L.latLng(
        (a.lat + b.lat) / 2,
        (a.lng + b.lng) / 2
      );

      const label = L.marker(mid, {
        icon: L.divIcon({
          className: "",
          html: `<div class="edge-label">${len.toFixed(2)} km</div>`
          // iconAnchor: [0, 0]

        })
      }).addTo(map);

      measureLabels.push(label);
    }
  }

  function addAreaLabel(points) {
    const coords = [...points, points[0]].map(p => [p.lng, p.lat]);

    const area = turf.area(turf.polygon([coords])) / 1_000_000;

    const center = turf.centroid(turf.polygon([coords])).geometry.coordinates;

    const label = L.marker([center[1], center[0]], {
      icon: L.divIcon({
        className: "",
        html: `<div class="area-label">${area.toFixed(2)} kmÂ²</div>`
      })
    }).addTo(map);

    measureLabels.push(label);
  }

  function clearMeasurement(resetPoints = true) {
    if (measureLayer) map.removeLayer(measureLayer);
    measureLabels.forEach(l => map.removeLayer(l));

    measureLayer = null;
    measureLabels = [];

    if (resetPoints) {
      measureHandles.forEach(h => map.removeLayer(h));
      measureHandles = [];
      measurePoints = [];
    }
  }

  function createHandle(latlng, index) {
    const handle = L.marker(latlng, {
      draggable: true,
      icon: L.divIcon({
        className: "measure-handle",
        iconSize: [12, 12]
      })
    }).addTo(map);

    handle.on("dragstart", () => {
      map.dragging.disable();
    });

    handle.on("drag", (e) => {
      measurePoints[index] = e.target.getLatLng();
      redrawMeasurement();
    });

    handle.on("dragend", () => {
      map.dragging.enable();
    });

    measureHandles.push(handle);
  }

  const teleportPanel = document.getElementById("teleportPanel");

  const teleLat = document.getElementById("teleLat");
  const teleLng = document.getElementById("teleLng");
  const teleZoom = document.getElementById("teleZoom");

  teleLat.addEventListener("input", applyTeleportInputs);
  teleLng.addEventListener("input", applyTeleportInputs);
  teleZoom.addEventListener("input", applyTeleportInputs);

  function applyTeleportInputs() {
    const lat = parseFloat(teleLat.value);
    const lng = parseFloat(teleLng.value);
    const zoom = parseInt(teleZoom.value);

    if (
      Number.isNaN(lat) ||
      Number.isNaN(lng) ||
      Number.isNaN(zoom)
    ) return;

    map.setView([lat, lng], zoom, { animate: true });
  }


  function updateTeleportInputs() {
    const center = map.getCenter();
    const zoom = map.getZoom();

    teleLat.value = center.lat.toFixed(6);
    teleLng.value = center.lng.toFixed(6);
    teleZoom.value = zoom;
  }

  // initial
  updateTeleportInputs();

  // bei jeder Ã„nderung
  map.on("moveend zoomend", updateTeleportInputs);























  const screenshotButton = document.getElementById("myScreenshot");

  function updateScreenshotButton() {
    screenshotButton.style.display = activeMode === "distance" ? "inline-block" : "none";
  }

  updateScreenshotButton();
  screenshotButton.addEventListener("click", takeMapSnapshot);

  function takeMapSnapshot() {
    if (!measurePoints || measurePoints.length === 0) {
      // Kein Punkt, Screenshot des aktuellen Viewports
      leafletImage(map, (err, canvas) => {
        if (err) return console.error(err);
        downloadCanvas(canvas, map.getCenter(), map.getZoom());
      });
      return;
    }

    // Berechne Bounding Box der markierten Punkte
    const lats = measurePoints.map(p => p.lat);
    const lngs = measurePoints.map(p => p.lng);
    const southWest = L.latLng(Math.min(...lats), Math.min(...lngs));
    const northEast = L.latLng(Math.max(...lats), Math.max(...lngs));
    const bounds = L.latLngBounds(southWest, northEast);

    // Erstelle temporÃ¤re Map, nur fÃ¼r Screenshot
    const tempMap = map; // Leaflet kann nur das bestehende Canvas nutzen, wir zoomen deshalb so, dass alles passt

    map.fitBounds(bounds, { padding: [20, 20] }); // Zoom, sodass alle Punkte drin sind

    setTimeout(() => {
      leafletImage(map, (err, canvas) => {
        if (err) return console.error(err);
        downloadCanvas(canvas, bounds.getCenter(), map.getZoom());
        // Zoom wieder zurÃ¼cksetzen
        map.fitBounds(bounds, { padding: [0, 0] });
      });
    }, 300); // kurz warten, bis Map gerendert ist
  }

  function downloadCanvas(canvas, center, zoom) {
    const link = document.createElement("a");
    link.href = canvas.toDataURL("image/png");

    const lat = center.lat.toFixed(1);
    const lng = center.lng.toFixed(1);
    link.download = `Map-Lat${lat}-Lng${lng}-Zm${zoom}.png`;
    link.click();
  }

</script>

</body>
</html>
