<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>tripmap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="./style.css">
</head>
<body>
<div class="controls options">
  <!-- <div class="function"><button id="">âœˆï¸</button><span>Option 1</span></div> -->
  <div class="function"><button id="myZoomIn">â•</button><span>Zoom In</span></div>
  <div class="function"><button id="myZoomOut">â–</button><span>Zoom Out</span></div>
</div>

<div class="controls pencil">
  <div class="function"><button data-mode="country">ğŸ–±ï¸</button></div>
  <div class="function"><button data-mode="distance">âœˆï¸</button></div>
  <div class="function"><button data-mode="trip">ğŸ“</button></div>
</div>
<div id="infoPanel">
  <div id="infoName">Click somewher...</div>
  <div id="infoContent">Click on a country to see more information here.</div>
</div>
<div id="infoRest"></div>

<div id="map"></div>
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script type="module">
  import { ref, get, set } from "https://www.gstatic.com/firebasejs/10.3.0/firebase-database.js";
  import { db } from "./database.js";
  import { countryCapitals } from "./data.js";
  // import fetch from "node-fetch";
  const map = L.map("map", { zoomControl:false }).setView([20, 0], 3);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom:19, attribution:"Â© OpenStreetMap contributors" }).addTo(map);
  // L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",{attribution: "Â© OpenStreetMap Â© CARTO"}).addTo(map);
  const infoContent = document.getElementById('infoContent');
  const infoName = document.getElementById('infoName');
  const infoRest = document.getElementById('infoRest');

  let comparisonLayer = null;
  let comparisonFeature = null;
  let isDraggingComparison = false;
  let geojsonLayer;
  let selectedCountryPolygon = null;
  let selectedCountryName = null;
  let selectedCountryLayer = null;
  let randomHighlightInterval = null;
  let lastRandomLayer = null;
  const BLINK_INTERVAL_MS = 100;
  const MIN_AREA_KM2 = 3_000_000; // z.B. ~ Australien
  let blinkingLayers = [];
  let allCountriesWithArea = [];
  let activeMode = "country"; // default
  let comparisonBaseFeature = null;   // NIE verÃ¤ndern
  let comparisonOffset = { km: 0, bearing: 0 };

  const pencilButtons = document.querySelectorAll(".controls.pencil button");

  pencilButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      // UI
      pencilButtons.forEach(b => b.classList.remove("active"));
      btn.classList.add("active");

      // Mode setzen
      activeMode = btn.dataset.mode;

      // Cleanup
      resetModes();
    });
  });

  function resetModes() {
    // Flight cleanup
    measurePoints = [];
    clearMeasurement();

    // Map cursor
    map.getContainer().classList.toggle(
      "flight-mode",
      activeMode === "distance"
    );

    if (activeMode === "country") {
      startAreaBasedBlinking();
    } else {
      stopAreaBasedBlinking();
    }
  }


  map.on("click", (e) => {
    switch (activeMode) {
      case "distance":
        handleDistanceClick(e);
        break;

      case "trip":
        handleTripClick(e);
        break;

      case "country":
      default:
        // LÃ¤nder werden Ã¼ber onEachCountry behandelt
        break;
    }
  });

  map.on("contextmenu", () => {
    if (activeMode === "distance") {
      clearMeasurement(true);
    }
  });
  // function startRandomHighlight() {
  //   randomHighlightInterval = setInterval(() => {
  //     // Nur wenn kein Land ausgewÃ¤hlt ist
  //     if (!selectedCountryLayer && geojsonLayer) {
  //       const layers = geojsonLayer.getLayers();
  //       if (layers.length === 0) return;

  //       // Vorheriges zurÃ¼cksetzen
  //       if (lastRandomLayer && lastRandomLayer !== selectedCountryLayer) {
  //         geojsonLayer.resetStyle(lastRandomLayer);
  //       }

  //       // ZufÃ¤lliges Layer auswÃ¤hlen
  //       const randomIndex = Math.floor(Math.random() * layers.length);
  //       const layer = layers[randomIndex];

  //       // Nur markieren, wenn es nicht gerade ausgewÃ¤hlt ist
  //       if (layer !== selectedCountryLayer) {
  //         layer.setStyle({
  //           color: "#555",
  //           weight: 1,
  //           fillColor: "black",
  //           fillOpacity: 1
  //         });
  //         lastRandomLayer = layer;
  //       }
  //     }
  //   }, 100);
  // }

  function addClass(layer, className) {
    const el = layer.getElement();
    if (el) el.classList.add(className);
  }

  function removeClass(layer, className) {
    const el = layer.getElement();
    if (el) el.classList.remove(className);
  }

  
  let blinkInterval = null;

  function startAreaBasedBlinking() {
    if (blinkInterval) return;

    blinkInterval = setInterval(() => {
      if (activeMode !== "country") return;
      if (selectedCountryLayer) return;

      blinkingLayers.forEach(l => removeClass(l, "country-blink"));
      blinkingLayers = [];

      let totalArea = 0;
      const shuffled = [...allCountriesWithArea].sort(() => Math.random() - 0.5);

      for (const { layer, areaKm2 } of shuffled) {
        addClass(layer, "country-blink");
        blinkingLayers.push(layer);
        totalArea += areaKm2;
        if (totalArea >= MIN_AREA_KM2) break;
      }
    }, BLINK_INTERVAL_MS);
  }

  function stopAreaBasedBlinking() {
    if (!blinkInterval) return;

    clearInterval(blinkInterval);
    blinkInterval = null;

    blinkingLayers.forEach(l => removeClass(l, "country-blink"));
    blinkingLayers = [];
  }



  function onEachCountry(feature, layer) {
    layer.on({
      mouseover: () => {
        if (activeMode !== "country") return;
        if (layer !== selectedCountryLayer) {
          addClass(layer, "country-hover");
        }
      },

      mouseout: () => {
        if (layer !== selectedCountryLayer) {
          removeClass(layer, "country-hover");
        }
      },

      click: () => {
        if (activeMode !== "country") return;
        if (layer === selectedCountryLayer) {
          removeClass(layer, "country-selected");
          selectedCountryLayer = null;
          selectedCountryPolygon = null;
          selectedCountryName = null;
          infoContent.style.display = "none";
          infoName.style.display = "none";
          return;
        }

        if (selectedCountryLayer) {
          removeClass(selectedCountryLayer, "country-selected");
        }

        selectedCountryLayer = layer;
        selectedCountryPolygon = feature.geometry;
        selectedCountryName = feature.properties.ADMIN;
        createComparisonCopy(feature, layer.getBounds().getCenter());

        addClass(layer, "country-selected");
        removeClass(layer, "country-hover");
        for (const blinkLayer of blinkingLayers) {
          removeClass(blinkLayer, "country-blink");
        }
        blinkingLayers = [];
        infoName.textContent = selectedCountryName;
        infoContent.style.display = "flex";
        infoName.style.display = "flex";
        
        fetchAIIntro(selectedCountryName);
        fetchRestCountries(selectedCountryName);

      }
    });
  }

  function createComparisonCopy(feature, referenceLatLng) {
    if (comparisonLayer) map.removeLayer(comparisonLayer);

    let base = turf.clone(feature);

    // Mercator-Korrektur EINMAL
    base = scaleCountryRealistic(base, referenceLatLng.lat);

    comparisonBaseFeature = base;
    comparisonOffset = { km: 0, bearing: 0 };

    renderComparison(referenceLatLng);
    enableComparisonDragging();
  }

  function renderComparison(targetLatLng) {
    let rendered = turf.clone(comparisonBaseFeature);

    const from = turf.centroid(rendered);
    const to = turf.point([targetLatLng.lng, targetLatLng.lat]);

    const km = turf.distance(from, to, { units: "kilometers" });
    const bearing = turf.bearing(from, to);

    rendered = turf.transformTranslate(rendered, km, bearing, {
      units: "kilometers"
    });

    comparisonFeature = rendered;

    if (comparisonLayer) map.removeLayer(comparisonLayer);
    comparisonLayer = L.geoJSON(rendered, {
      className: "country comparison",
      style: {
        color: "#00ffff",
        weight: 2,
        fillOpacity: 0.15
      }
    }).addTo(map);
  }


  function translateToLatLng(feature, targetLatLng) {
    const centroid = turf.centroid(feature).geometry.coordinates;

    const from = turf.point(centroid);
    const to = turf.point([targetLatLng.lng, targetLatLng.lat]);

    const distanceKm = turf.distance(from, to, { units: "kilometers" });
    const bearing = turf.bearing(from, to);

    return turf.transformTranslate(feature, distanceKm, bearing, {
      units: "kilometers"
    });
  }

  function scaleCountryRealistic(feature, targetLat = 0) {
    const centroid = turf.centroid(feature).geometry.coordinates;
    const lat = centroid[1];

    // Mercator-Korrektur (sehr wichtig)
    const scaleCorrection =
      Math.cos((lat * Math.PI) / 180) /
      Math.cos((targetLat * Math.PI) / 180);

    return turf.transformScale(feature, scaleCorrection, {
      origin: "centroid"
    });
  }


  function enableComparisonDragging() {
    if (!comparisonLayer) return;

    comparisonLayer.eachLayer(layer => {
      layer.on("mousedown", e => {
        isDraggingComparison = true;
        map.dragging.disable();
      });
    });

    map.on("mousemove", e => {
      console.log("mousemove");
      console.log(isDraggingComparison, comparisonBaseFeature);
      if (!isDraggingComparison || !comparisonBaseFeature) return;

      renderComparison(e.latlng);
    });


    map.on("mouseup", () => {
      isDraggingComparison = false;
      map.dragging.enable();
    });
  }


  fetch("https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_10m_admin_0_countries.geojson")
  .then(res => res.json())
  .then(data => {
    geojsonLayer = L.geoJSON(data, {
      className: "country",
      onEachFeature: onEachCountry
    }).addTo(map);

    // FlÃ¤che einmal berechnen
    geojsonLayer.eachLayer(layer => {
      const feature = layer.feature;
      const areaKm2 = turf.area(feature) / 1_000_000;
      allCountriesWithArea.push({ layer, areaKm2 });
    });

    startAreaBasedBlinking();
  });

  async function fetchAIIntro(countryName) {
    const res = await fetch("/api/getIntro", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ countryName })
    });

    if (!res.ok) {
      infoContent.textContent = "AI unavailable, loading wikipediaâ€¦";
      setTimeout(() => {
        fetchWikiIntro(countryName);
      }, 2000);
      return;
    }

    const data = await res.json();
    infoContent.textContent = data.text;
  }

  
  const countryToWiki = {
    Germany: "Germany",
    France: "France",
    Spain: "Spain"
  };

  async function fetchWikiIntro(countryName) {
    infoContent.textContent = `AI unavailable, loading wikipediaâ€¦`;
    try {
      const wikiTitle = countryToWiki[countryName] || countryName;
      const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(wikiTitle)}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error("Wikipedia-Eintrag nicht gefunden.");
      const data = await res.json();
      infoContent.textContent = data.extract || "Keine Informationen verfÃ¼gbar.";
    } catch(e) {
      infoContent.textContent = `Fehler beim Laden von ${countryName}.`;
      console.error(e);
    }
  }

  async function fetchRestCountries(countryName) {
    infoContent.innerHTML = "Loading country dataâ€¦";

    const res = await fetch(
      `https://restcountries.com/v3.1/name/${encodeURIComponent(countryName)}?fullText=true`
    );

    if (!res.ok) {
      // infoContent.textContent = "No country data found.";
      return;
    }

    const [country] = await res.json();

    renderCountryAttributes(country);
  }

  function renderCountryAttributes(country) {
    // infoContent.innerHTML = "";
    const keysIWant = [
      "population",
      "timezones",
      "flag",
      "languages",
      "capital",
      "currencies"
    ];
    let i = 0;
    for (const [key, value] of Object.entries(country)) {
      // if (i++ >= 3) break;
      if (!keysIWant.includes(key)) continue;
      const content = document.createElement("div");
      content.classList.add("restInfoTile", "scroll-text");
      content.textContent = formatValue(value);
      infoRest.appendChild(content);
    }
  }

  function formatValue(value) {
    if (value == null) return "â€”";

    if (Array.isArray(value)) {
      return value.map(v => formatValue(v)).join(", ");
    }

    if (typeof value === "object") {
      return Object.values(value)
        .map(v => formatValue(v))
        .join(", ");
    }

    return value.toString();
  }


  // Zoom Buttons
  document.getElementById("myZoomIn").addEventListener("click", () => map.zoomIn());
  document.getElementById("myZoomOut").addEventListener("click", () => map.zoomOut());

  let flightMode = false;
  let measurePoints = [];
  let measureLayer = null;
  let measureLabels = [];
  let measureHandles = [];

  function handleDistanceClick(e) {
    measurePoints.push(e.latlng);
    createHandle(e.latlng, measurePoints.length - 1);
    redrawMeasurement();
  }

  function redrawMeasurement() {
    clearMeasurement(false);

    if (measurePoints.length < 2) return;

    if (measurePoints.length === 2) {
      measureLayer = L.polyline(measurePoints, {
        color: "white",
        weight: 2
      }).addTo(map);

      addEdgeLabels(measurePoints);
    } else {
      measureLayer = L.polygon(measurePoints, {
        color: "white",
        fillOpacity: 0.2
      }).addTo(map);

      addEdgeLabels(measurePoints, true);
      addAreaLabel(measurePoints);
    }
  }


  function addEdgeLabels(points, closed = false) {
    const pts = closed ? [...points, points[0]] : points;

    for (let i = 0; i < pts.length - 1; i++) {
      const a = pts[i];
      const b = pts[i + 1];

      const len = turf.distance(
        [a.lng, a.lat],
        [b.lng, b.lat],
        { units: "kilometers" }
      );

      const mid = L.latLng(
        (a.lat + b.lat) / 2,
        (a.lng + b.lng) / 2
      );

      const label = L.marker(mid, {
        icon: L.divIcon({
          className: "",
          html: `<div class="edge-label">${len.toFixed(2)} km</div>`
          // iconAnchor: [0, 0]

        })
      }).addTo(map);

      measureLabels.push(label);
    }
  }

  function addAreaLabel(points) {
    const coords = [...points, points[0]].map(p => [p.lng, p.lat]);

    const area = turf.area(turf.polygon([coords])) / 1_000_000;

    const center = turf.centroid(turf.polygon([coords])).geometry.coordinates;

    const label = L.marker([center[1], center[0]], {
      icon: L.divIcon({
        className: "",
        html: `<div class="area-label">${area.toFixed(2)} kmÂ²</div>`
      })
    }).addTo(map);

    measureLabels.push(label);
  }

  function clearMeasurement(resetPoints = true) {
    if (measureLayer) map.removeLayer(measureLayer);
    measureLabels.forEach(l => map.removeLayer(l));

    measureLayer = null;
    measureLabels = [];

    if (resetPoints) {
      measureHandles.forEach(h => map.removeLayer(h));
      measureHandles = [];
      measurePoints = [];
    }
  }

  function createHandle(latlng, index) {
    const handle = L.marker(latlng, {
      draggable: true,
      icon: L.divIcon({
        className: "measure-handle",
        iconSize: [12, 12]
      })
    }).addTo(map);

    handle.on("dragstart", () => {
      map.dragging.disable();
    });

    handle.on("drag", (e) => {
      measurePoints[index] = e.target.getLatLng();
      redrawMeasurement();
    });

    handle.on("dragend", () => {
      map.dragging.enable();
    });

    measureHandles.push(handle);
  }



</script>

</body>
</html>
