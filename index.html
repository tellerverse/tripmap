<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Reisekarte mit Ländern & Flugzeugen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="../style.css">
</head>
<body>
<div class="controls">
  Planes <button id="loadPlanesBtn">x</button>
  <div class="my-controls">
    Zoom:
    <button id="myZoomIn">+</button>
    <button id="myZoomOut">−</button>
  </div>
</div>
<div id="infoPanel">Klicke ein Land, um Infos zu sehen.</div>
<div id="map"></div>
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script type="module">
  import { ref, get, set } from "https://www.gstatic.com/firebasejs/10.3.0/firebase-database.js";
  import { db } from "./database.js";
  import { countryCapitals } from "./data.js";
  const map = L.map("map", { zoomControl:false }).setView([20, 0], 3);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom:19, attribution:"© OpenStreetMap contributors" }).addTo(map);
  // L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",{attribution: "© OpenStreetMap © CARTO"}).addTo(map);
  const infoPanel = document.getElementById('infoPanel');

  let geojsonLayer;
  let selectedCountryPolygon = null;
  let selectedCountryName = null;
  let selectedCountryLayer = null;
  let randomHighlightInterval = null;
  let lastRandomLayer = null;
  const BLINK_INTERVAL_MS = 100;
  const MIN_AREA_KM2 = 3_000_000; // z.B. ~ Australien
  let blinkingLayers = [];
  let allCountriesWithArea = [];

  // function startRandomHighlight() {
  //   randomHighlightInterval = setInterval(() => {
  //     // Nur wenn kein Land ausgewählt ist
  //     if (!selectedCountryLayer && geojsonLayer) {
  //       const layers = geojsonLayer.getLayers();
  //       if (layers.length === 0) return;

  //       // Vorheriges zurücksetzen
  //       if (lastRandomLayer && lastRandomLayer !== selectedCountryLayer) {
  //         geojsonLayer.resetStyle(lastRandomLayer);
  //       }

  //       // Zufälliges Layer auswählen
  //       const randomIndex = Math.floor(Math.random() * layers.length);
  //       const layer = layers[randomIndex];

  //       // Nur markieren, wenn es nicht gerade ausgewählt ist
  //       if (layer !== selectedCountryLayer) {
  //         layer.setStyle({
  //           color: "#555",
  //           weight: 1,
  //           fillColor: "black",
  //           fillOpacity: 1
  //         });
  //         lastRandomLayer = layer;
  //       }
  //     }
  //   }, 100);
  // }

  function addClass(layer, className) {
    const el = layer.getElement();
    if (el) el.classList.add(className);
  }

  function removeClass(layer, className) {
    const el = layer.getElement();
    if (el) el.classList.remove(className);
  }

  
  function startAreaBasedBlinking() {
    setInterval(() => {
      if (selectedCountryLayer) return;

      blinkingLayers.forEach(l => removeClass(l, "country-blink"));
      blinkingLayers = [];

      let totalArea = 0;

      const shuffled = [...allCountriesWithArea].sort(() => Math.random() - 0.5);

      for (const { layer, areaKm2 } of shuffled) {
        addClass(layer, "country-blink");
        blinkingLayers.push(layer);
        totalArea += areaKm2;

        if (totalArea >= MIN_AREA_KM2) break;
      }
    }, BLINK_INTERVAL_MS);
  }



  function onEachCountry(feature, layer) {
    layer.on({
      mouseover: () => {
        if (layer !== selectedCountryLayer) {
          addClass(layer, "country-hover");
        }
      },

      mouseout: () => {
        if (layer !== selectedCountryLayer) {
          removeClass(layer, "country-hover");
        }
      },

      click: () => {
        if (layer === selectedCountryLayer) {
          removeClass(layer, "country-selected");
          selectedCountryLayer = null;
          selectedCountryPolygon = null;
          selectedCountryName = null;
          infoPanel.textContent = "Klicke ein Land, um Infos zu sehen.";
          return;
        }

        if (selectedCountryLayer) {
          removeClass(selectedCountryLayer, "country-selected");
        }

        selectedCountryLayer = layer;
        selectedCountryPolygon = feature.geometry;
        selectedCountryName = feature.properties.ADMIN;

        addClass(layer, "country-selected");
        removeClass(layer, "country-hover");
        for (const blinkLayer of blinkingLayers) {
          removeClass(blinkLayer, "country-blink");
        }
        blinkingLayers = [];
        infoPanel.textContent = `Ausgewähltes Land: ${selectedCountryName}`;
        fetchAIIntro(selectedCountryName);
        // Oder Wikipedia-Intro:
        fetchWikiIntro(selectedCountryName);
      }
    });
  }


  fetch("https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_10m_admin_0_countries.geojson")
  .then(res => res.json())
  .then(data => {
    geojsonLayer = L.geoJSON(data, {
      className: "country",
      onEachFeature: onEachCountry
    }).addTo(map);

    // Fläche einmal berechnen
    geojsonLayer.eachLayer(layer => {
      const feature = layer.feature;
      const areaKm2 = turf.area(feature) / 1_000_000;
      allCountriesWithArea.push({ layer, areaKm2 });
    });

    startAreaBasedBlinking();
  });

  async function fetchAIIntro(countryName) {
    const res = await fetch("/api/getIntro", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ countryName })
    });

    const data = await res.json();
    infoPanel.textContent = data.text;
  }
  
  const countryToWiki = {
    Germany: "Germany",
    France: "France",
    Spain: "Spain"
  };

  async function fetchWikiIntro(countryName) {
    infoPanel.textContent = `Lade Infos zu ${countryName}…`;
    try {
      const wikiTitle = countryToWiki[countryName] || countryName;
      const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(wikiTitle)}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error("Wikipedia-Eintrag nicht gefunden.");
      const data = await res.json();
      infoPanel.textContent = data.extract || "Keine Informationen verfügbar.";
    } catch(e) {
      infoPanel.textContent = `Fehler beim Laden von ${countryName}.`;
      console.error(e);
    }
  }

  // Zoom Buttons
  document.getElementById("myZoomIn").addEventListener("click", () => map.zoomIn());
  document.getElementById("myZoomOut").addEventListener("click", () => map.zoomOut());
  
  // Flugzeug-Logik
  const planeIcon = L.icon({
    iconUrl: "./Assets/plane.png", // <-- DEIN Flugzeugbild
    iconSize: [24, 24],
    iconAnchor: [12, 12],
    className: "plane-icon"
  });
  let planeMarkers = [];
  let selectedRoute = null;
  let buttonCooldown = false;

  const loadPlanesBtn = document.getElementById('loadPlanesBtn');
  loadPlanesBtn.addEventListener('click', async () => {loadPlanes()});

  function pointInPolygon(point, polygon) {
    const [x, y] = point;

    const rings =
      polygon.type === "Polygon"
        ? polygon.coordinates
        : polygon.coordinates.flat();

    return rings.some(ring => {
      let inside = false;
      for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        const xi = ring[i][0], yi = ring[i][1];
        const xj = ring[j][0], yj = ring[j][1];

        const intersect =
          yi > y !== yj > y &&
          x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;

        if (intersect) inside = !inside;
      }
      return inside;
    });
  }


  async function loadPlanes() {
    if (!selectedCountryPolygon) {
      alert("Bitte zuerst ein Land auswählen.");
      return;
    }
    try {
      const res = await fetch("https://opensky-network.org/api/states/all");
      const data = await res.json();

      // Alte Marker entfernen
      planeMarkers.forEach(m => map.removeLayer(m));
      if(selectedRoute) { map.removeLayer(selectedRoute); selectedRoute = null; }
      planeMarkers = [];

      data.states.forEach(state => {
        const [icao24, callsign, originCountry, timePos, lastContact, lon, lat, baroAlt, onGround] = state;

        if (
          // !onGround &&
          lat &&
          lon &&
          pointInPolygon([lon, lat], selectedCountryPolygon)
        ) {

          const capital = countryCapitals[originCountry]; // Hauptstadt als Ziel
          const marker = L.marker([lat, lon], {
            icon: planeIcon,
            pane: "markerPane"
          }).addTo(map);


          marker.planeData = { 
            start: [lat, lon], 
            end: capital || null, // Hauptstadt oder null
            callsign: callsign?.trim() || "Unbekannt",
            country: originCountry
          };

          marker.on("mouseover", () => {
            marker.getElement()?.classList.add("hovered");
          });

          marker.on("mouseout", () => {
            marker.getElement()?.classList.remove("hovered");
          });


          marker.on('click', () => highlightPlane(marker));

          planeMarkers.push(marker);
        }

      });

      console.log(`Es wurden ${planeMarkers.length} Flugzeuge geladen.`);
      // Hole Zeitstempel aus Firestore
      const snapshot = await get(ref(db, `planes/cooldown`));
      const now = Date.now();

      if(snapshot.exists()) {
        const lastTime = snapshot.val() || 0;
        if(now - lastTime < 30000) {
          const wait = Math.ceil((30000 - (now - lastTime))/1000);
          alert(`Bitte noch ${wait} Sekunden warten!`);
          return;
        }
      }

      // Cooldown aktualisieren
      await set(ref(db, `planes/cooldown`), now);

    } catch(err) {
      console.error("Fehler beim Laden der OpenSky-Daten:", err);
      alert("Fehler beim Laden der Flugzeugdaten. Eventuell CORS-Problem.");
    }
  }

  function highlightPlane(selected) {
    planeMarkers.forEach(m => {
      const el = m.getElement();
      if (!el) return;

      if (m === selected) {
        el.classList.remove("dimmed");
      } else {
        el.classList.add("dimmed");
      }
    });

    if (selectedRoute) map.removeLayer(selectedRoute);

    const p = selected.planeData;
    if (p.end) {
      selectedRoute = L.polyline([p.start, p.end], {
        color: "red",
        weight: 2
      }).addTo(map);

      map.fitBounds([p.start, p.end], { padding: [50, 50] });
    }
  }
</script>

</body>
</html>
