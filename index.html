<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>tripmap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="./style.css">
</head>
<body>
<div class="controls options">
  <div class="function"><button id="myZoomIn">‚ûï</button><span>Zoom In</span></div>
  <div class="function"><button id="myZoomOut">‚ûñ</button><span>Zoom Out</span></div>
  <div class="function"><button id="myScreenshot">üì∏</button><span>Snapshot</span></div>
</div>

<div class="controls pencil">
  <div class="function"><button data-mode="country" class="active">üñ±Ô∏è</button></div>
  <div class="function"><button data-mode="distance">‚úàÔ∏è</button></div>
  <div class="function"><button data-mode="trip">üìç</button></div>
</div>
<div id="infoPanel">
  <div id="infoName">Click somewher...</div>
  <div id="infoContent">Click on a country to see more information here.</div>
</div>
<div id="infoRest"></div>
<div id="teleportPanel" class="teleport-panel">
  <input id="teleLat" type="number" min="-90" max="90" placeholder="Lat">
  <input id="teleLng" type="number" min="-180" max="180" placeholder="Lon">
  <input id="teleZoom" type="number" min="1" max="19" placeholder="Zoom">
</div>
<div id="map"></div>
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>
<script type="module">
  import { ref, get, set } from "https://www.gstatic.com/firebasejs/10.3.0/firebase-database.js";
  import { db } from "./database.js";

  const map = L.map("map", { zoomControl:false }).setView([20, 0], 3);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom:19, attribution:"¬© OpenStreetMap contributors" }).addTo(map);
  // L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",{attribution: "¬© OpenStreetMap ¬© CARTO"}).addTo(map);
  const infoContent = document.getElementById('infoContent');
  const infoName = document.getElementById('infoName');
  const infoRest = document.getElementById('infoRest');

  let comparisonCentroid;
  let comparisonLayer = null;
  let isDraggingComparison = false;
  let geojsonLayer;
  let selectedCountryPolygon = null;
  let selectedCountryName = null;
  let selectedCountryLayer = null;
  const BLINK_INTERVAL_MS = 100;
  const MIN_AREA_KM2 = 3_000_000;
  let blinkingLayers = [];
  let allCountriesWithArea = [];
  let activeMode = "country";
  let comparisonBaseFeature = null;
  let tripModeEnabled = false;
  let tripMarkers = new Map();
  let selectedTripMarker = null;

  const pencilButtons = document.querySelectorAll(".controls.pencil button");

  pencilButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      pencilButtons.forEach(b => b.classList.remove("active"));
      btn.classList.add("active");

      activeMode = btn.dataset.mode;
      
      resetModes();
    });
  });

  function resetModes() {
    measurePoints = [];
    clearMeasurement();
    despawnComparison();
    updateScreenshotButton();
    tripAddBtn.style.display = activeMode === "trip" ? "inline-block" : "none";
    tripModeEnabled = false;
    tripAddBtn.classList.remove("active");
    if (selectedCountryLayer) {
      removeClass(selectedCountryLayer, "country-selected");
      removeClass(selectedCountryLayer, "country-hover");

      selectedCountryLayer = null;
      selectedCountryPolygon = null;
      selectedCountryName = null;

      infoContent.style.display = "none";
      infoName.style.display = "none";
    }

    map.getContainer().classList.toggle(
      "flight-mode",
      activeMode === "distance"
    );

    if (activeMode === "country") {
      startAreaBasedBlinking();
    } else {
      stopAreaBasedBlinking();
    }
  }

  map.on("click", (e) => {
    switch (activeMode) {
      case "distance":
        handleDistanceClick(e);
        break;

      case "trip":
        handleTripClick(e);
        break;

      case "country":
      default:
        break;
    }
  });

  map.on("contextmenu", () => {
    if (activeMode === "distance") {
      clearMeasurement(true);
    }
  });

  function addClass(layer, className) {
    const el = layer.getElement();
    if (el) el.classList.add(className);
  }

  function removeClass(layer, className) {
    const el = layer.getElement();
    if (el) el.classList.remove(className);
  }

  let blinkInterval = null;

  function startAreaBasedBlinking() {
    if (blinkInterval) return;

    blinkInterval = setInterval(() => {
      if (activeMode !== "country") return;
      if (selectedCountryLayer) return;

      blinkingLayers.forEach(l => removeClass(l, "country-blink"));
      blinkingLayers = [];

      let totalArea = 0;
      const shuffled = [...allCountriesWithArea].sort(() => Math.random() - 0.5);

      for (const { layer, areaKm2 } of shuffled) {
        addClass(layer, "country-blink");
        blinkingLayers.push(layer);
        totalArea += areaKm2;
        if (totalArea >= MIN_AREA_KM2) break;
      }
    }, BLINK_INTERVAL_MS);
  }

  function stopAreaBasedBlinking() {
    if (!blinkInterval) return;

    clearInterval(blinkInterval);
    blinkInterval = null;

    blinkingLayers.forEach(l => removeClass(l, "country-blink"));
    blinkingLayers = [];
  }

  function onEachCountry(feature, layer) {
    layer.on({
      mouseover: () => {
        if (activeMode !== "country") return;
        if (layer !== selectedCountryLayer) {
          addClass(layer, "country-hover");
        }
      },

      mouseout: () => {
        if (layer !== selectedCountryLayer) {
          removeClass(layer, "country-hover");
        }
      },

      click: () => {
        if (activeMode !== "country") return;
        if (layer === selectedCountryLayer) {
          removeClass(layer, "country-selected");
          selectedCountryLayer = null;
          selectedCountryPolygon = null;
          selectedCountryName = null;
          despawnComparison();
          infoContent.style.display = "none";
          infoName.style.display = "none";
          return;
        }

        if (selectedCountryLayer) {
          removeClass(selectedCountryLayer, "country-selected");
        }

        selectedCountryLayer = layer;
        selectedCountryPolygon = feature.geometry;
        selectedCountryName = feature.properties.ADMIN;
        createComparisonCopy(feature, layer.getBounds().getCenter());

        addClass(layer, "country-selected");
        removeClass(layer, "country-hover");
        for (const blinkLayer of blinkingLayers) {
          removeClass(blinkLayer, "country-blink");
        }
        blinkingLayers = [];
        infoName.textContent = selectedCountryName;
        infoContent.style.display = "flex";
        infoName.style.display = "flex";
        
        fetchAIIntro(selectedCountryName);
        fetchRestCountries(selectedCountryName);
      }
    });
  }

  function createComparisonCopy(feature) {
    comparisonBaseFeature = turf.clone(feature);
    comparisonCentroid = turf.centroid(feature);

    // üî• Startposition = Original-Land
    const [lng, lat] = comparisonCentroid.geometry.coordinates;

    renderComparison(comparisonTargetLatLng);
    enableComparisonDragging();
  }

  function renderComparison(targetLatLng) {
    const sourceCenter = comparisonCentroid.geometry.coordinates;
    const sourceLatLng = L.latLng(sourceCenter[1], sourceCenter[0]);

    const p0 = project(sourceLatLng);
    const p1 = project(targetLatLng);

    const scale =
      Math.cos(sourceLatLng.lat * Math.PI / 180) /
      Math.cos(targetLatLng.lat * Math.PI / 180);

    const dx = p1.x - p0.x;
    const dy = p1.y - p0.y;

    const moved = turf.clone(comparisonBaseFeature);

    turf.coordEach(moved, coord => {
      const latlng = L.latLng(coord[1], coord[0]);
      const p = project(latlng);

      const scaled = L.point(
        p0.x + (p.x - p0.x) * scale + dx,
        p0.y + (p.y - p0.y) * scale + dy
      );

      const ll = unproject(scaled);
      coord[0] = ll.lng;
      coord[1] = ll.lat;
    });

    if (comparisonLayer) map.removeLayer(comparisonLayer);
    comparisonLayer = L.geoJSON(moved, {
      className: "country comparison",
      style: {
        color: "#00ffff",
        weight: 2,
        fillOpacity: 0.15
      }
    }).addTo(map);
    comparisonLayer.on("mousedown", e => {
      L.DomEvent.stopPropagation(e);
      L.DomEvent.preventDefault(e);

      isDraggingComparison = true;
      map.dragging.disable();
    });
  }

  function project(latlng) {
    return map.options.crs.project(latlng);
  }

  function unproject(point) {
    return map.options.crs.unproject(point);
  }

  function despawnComparison() {
    if (comparisonLayer) {
      map.removeLayer(comparisonLayer);
      comparisonLayer = null;
    }

    comparisonBaseFeature = null;
    comparisonCentroid = null;
    isDraggingComparison = false;

    map.dragging.enable();
  }

  function enableComparisonDragging() {
    if (!comparisonLayer) return;

    map.on("mousedown", e => {
      if (isDraggingComparison) {
        L.DomEvent.stopPropagation(e);
        map.dragging.disable();
      }
    });

    map.on("mousemove", e => {
      if (!isDraggingComparison || !comparisonBaseFeature) return;

      renderComparison(comparisonTargetLatLng);
    });

    map.on("mouseup", () => {
      isDraggingComparison = false;
      map.dragging.enable();
      // üéØ Zielposition bleibt gespeichert
    });
  }

  fetch("https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_10m_admin_0_countries.geojson")
  .then(res => res.json())
  .then(data => {
    geojsonLayer = L.geoJSON(data, {
      className: "country",
      onEachFeature: onEachCountry
    }).addTo(map);

    // Fl√§che einmal berechnen
    geojsonLayer.eachLayer(layer => {
      const feature = layer.feature;
      const areaKm2 = turf.area(feature) / 1_000_000;
      allCountriesWithArea.push({ layer, areaKm2 });
    });

    startAreaBasedBlinking();
  });

  async function fetchAIIntro(countryName) {
    const res = await fetch("/api/getIntro", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ countryName })
    });

    if (!res.ok) {
      infoContent.textContent = "AI unavailable, loading wikipedia‚Ä¶";
      setTimeout(() => {
        fetchWikiIntro(countryName);
      }, 2000);
      return;
    }

    const data = await res.json();
    infoContent.textContent = data.text;
  }

  const countryToWiki = {
    Germany: "Germany",
    France: "France",
    Spain: "Spain"
  };

  async function fetchWikiIntro(countryName) {
    infoContent.textContent = `AI unavailable, loading wikipedia‚Ä¶`;
    try {
      const wikiTitle = countryToWiki[countryName] || countryName;
      const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(wikiTitle)}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error("Wikipedia-Eintrag nicht gefunden.");
      const data = await res.json();
      infoContent.textContent = data.extract || "Keine Informationen verf√ºgbar.";
    } catch(e) {
      infoContent.textContent = `Fehler beim Laden von ${countryName}.`;
      console.error(e);
    }
  }

  async function fetchRestCountries(countryName) {
    infoContent.innerHTML = "Loading country data‚Ä¶";
    const res = await fetch(`https://restcountries.com/v3.1/name/${encodeURIComponent(countryName)}?fullText=true`);
    if (!res.ok) return;
    const [country] = await res.json();
    renderCountryAttributes(country);
  }

  function renderCountryAttributes(country) {
    // infoContent.innerHTML = "";
    const keysIWant = [
      "population",
      "timezones",
      "flag",
      "languages",
      "capital",
      "currencies"
    ];
    let i = 0;
    for (const [key, value] of Object.entries(country)) {
      // if (i++ >= 3) break;
      if (!keysIWant.includes(key)) continue;
      const content = document.createElement("div");
      content.classList.add("restInfoTile", "scroll-text");
      content.textContent = formatValue(value);
      infoRest.appendChild(content);
    }
  }

  function formatValue(value) {
    if (value == null) return "‚Äî";
    if (Array.isArray(value)) {
      return value.map(v => formatValue(v)).join(", ");
    }
    if (typeof value === "object") {
      return Object.values(value)
        .map(v => formatValue(v))
        .join(", ");
    }
    return value.toString();
  }

  document.getElementById("myZoomIn").addEventListener("click", () => map.zoomIn());
  document.getElementById("myZoomOut").addEventListener("click", () => map.zoomOut());
  const tripAddBtn = document.createElement("button");
  tripAddBtn.textContent = "‚ûï Trip";
  tripAddBtn.id = "addTripMarker";
  tripAddBtn.style.display = "none";
  document.querySelector(".controls.options").appendChild(tripAddBtn);

  tripAddBtn.onclick = () => {
    tripModeEnabled = !tripModeEnabled;
    tripAddBtn.classList.toggle("active", tripModeEnabled);
  };

  let measurePoints = [];
  let measureLayer = null;
  let measureLabels = [];
  let measureHandles = [];

  function handleDistanceClick(e) {
    measurePoints.push(e.latlng);
    createHandle(e.latlng, measurePoints.length - 1);
    redrawMeasurement();
  }

  function redrawMeasurement() {
    clearMeasurement(false);
    if (measurePoints.length < 2) return;
    if (measurePoints.length === 2) {
      measureLayer = L.polyline(measurePoints, {
        color: "white",
        weight: 2
      }).addTo(map);
      addEdgeLabels(measurePoints);
    } else {
      measureLayer = L.polygon(measurePoints, {
        color: "white",
        fillOpacity: 0.2
      }).addTo(map);
      addEdgeLabels(measurePoints, true);
      addAreaLabel(measurePoints);
    }
  }


  function addEdgeLabels(points, closed = false) {
    const pts = closed ? [...points, points[0]] : points;
    for (let i = 0; i < pts.length - 1; i++) {
      const a = pts[i];
      const b = pts[i + 1];

      const len = turf.distance(
        [a.lng, a.lat],
        [b.lng, b.lat],
        { units: "kilometers" }
      );
      const mid = L.latLng(
        (a.lat + b.lat) / 2,
        (a.lng + b.lng) / 2
      );
      const label = L.marker(mid, {
        icon: L.divIcon({
          className: "",
          html: `<div class="edge-label">${len.toFixed(2)} km</div>`
          // iconAnchor: [0, 0]

        })
      }).addTo(map);
      measureLabels.push(label);
    }
  }

  function addAreaLabel(points) {
    const coords = [...points, points[0]].map(p => [p.lng, p.lat]);
    const area = turf.area(turf.polygon([coords])) / 1_000_000;
    const center = turf.centroid(turf.polygon([coords])).geometry.coordinates;
    const label = L.marker([center[1], center[0]], {
      icon: L.divIcon({
        className: "",
        html: `<div class="area-label">${area.toFixed(2)} km¬≤</div>`
      })
    }).addTo(map);
    measureLabels.push(label);
  }

  function clearMeasurement(resetPoints = true) {
    if (measureLayer) map.removeLayer(measureLayer);
    measureLabels.forEach(l => map.removeLayer(l));
    measureLayer = null;
    measureLabels = [];
    if (resetPoints) {
      measureHandles.forEach(h => map.removeLayer(h));
      measureHandles = [];
      measurePoints = [];
    }
  }

  function createHandle(latlng, index) {
    const handle = L.marker(latlng, {
      draggable: true,
      icon: L.divIcon({
        className: "measure-handle",
        iconSize: [12, 12]
      })
    }).addTo(map);
    handle.on("dragstart", () => {map.dragging.disable();});
    handle.on("drag", (e) => {
      measurePoints[index] = e.target.getLatLng();
      redrawMeasurement();
    });
    handle.on("dragend", () => {map.dragging.enable();});
    measureHandles.push(handle);
  }

  const teleLat = document.getElementById("teleLat");
  const teleLng = document.getElementById("teleLng");
  const teleZoom = document.getElementById("teleZoom");
  teleLat.addEventListener("input", applyTeleportInputs);
  teleLng.addEventListener("input", applyTeleportInputs);
  teleZoom.addEventListener("input", applyTeleportInputs);

  function applyTeleportInputs() {
    const lat = parseFloat(teleLat.value);
    const lng = parseFloat(teleLng.value);
    const zoom = parseInt(teleZoom.value);
    if (Number.isNaN(lat) || Number.isNaN(lng) || Number.isNaN(zoom)) return;
    map.setView([lat, lng], zoom, { animate: true });
  }

  function updateTeleportInputs() {
    const center = map.getCenter();
    const zoom = map.getZoom();

    teleLat.value = center.lat.toFixed(6);
    teleLng.value = center.lng.toFixed(6);
    teleZoom.value = zoom;
  }

  updateTeleportInputs();
  map.on("moveend zoomend", updateTeleportInputs);

  function polygonToCanvasPath(ctx, points, offset) {
    ctx.beginPath();
    points.forEach((p, i) => {
      const pt = map.latLngToContainerPoint(p);
      const x = pt.x - offset.x;
      const y = pt.y - offset.y;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.closePath();
  }

  function boundsToPixelRect(bounds) {
    const nw = map.latLngToContainerPoint(bounds.getNorthWest());
    const se = map.latLngToContainerPoint(bounds.getSouthEast());
    return {
      x: Math.round(nw.x),
      y: Math.round(nw.y),
      w: Math.round(se.x - nw.x),
      h: Math.round(se.y - nw.y)
    };
  }
  
  function cropAndMaskCanvas(srcCanvas, bounds, polygonLatLngs) {
    const rect = boundsToPixelRect(bounds);

    const dst = document.createElement("canvas");
    dst.width = rect.w;
    dst.height = rect.h;
    const ctx = dst.getContext("2d");

    if (polygonLatLngs.length >= 3) {
      polygonToCanvasPath(ctx, polygonLatLngs, rect);
      ctx.clip();
    }
    ctx.drawImage(
      srcCanvas,
      rect.x, rect.y, rect.w, rect.h,
      0, 0, rect.w, rect.h
    );
    return dst;
  }

  function withoutMeasurementLayers(fn) {
    const layers = [...measureLabels, ...measureHandles];
    layers.forEach(l => map.removeLayer(l));
    fn();
    layers.forEach(l => map.addLayer(l));
  }

  const screenshotButton = document.getElementById("myScreenshot");

  function updateScreenshotButton() {
    screenshotButton.style.display = activeMode === "distance" ? "inline-block" : "none";
  }

  updateScreenshotButton();
  screenshotButton.addEventListener("click", takeMapSnapshot);

  function takeMapSnapshot() {
    if (!measurePoints || measurePoints.length === 0) {
      leafletImage(map, (err, canvas) => {
        if (err) return console.error(err);
        downloadCanvas(canvas, map.getCenter(), map.getZoom());
      });
      return;
    }

    if (measurePoints.length === 1) {
      const center = measurePoints[0];
      const zoom = map.getZoom();

      map.setView(center, zoom, { animate: false });

      setTimeout(() => {
        withoutMeasurementLayers(() => {
          leafletImage(map, (err, canvas) => {
            if (err) return console.error(err);
            downloadCanvas(canvas, center, zoom);
          });
        });
      }, 300);
      return;
    }

    const lats = measurePoints.map(p => p.lat);
    const lngs = measurePoints.map(p => p.lng);
    const southWest = L.latLng(Math.min(...lats), Math.min(...lngs));
    const northEast = L.latLng(Math.max(...lats), Math.max(...lngs));
    const bounds = L.latLngBounds(
      [Math.min(...lats), Math.min(...lngs)],
      [Math.max(...lats), Math.max(...lngs)]
    );
    map.fitBounds(bounds, { padding: [0, 0] });
    setTimeout(() => {
      withoutMeasurementLayers(() => {
        leafletImage(map, (err, fullCanvas) => {
          if (err) return console.error(err);

          const masked = cropAndMaskCanvas(
            fullCanvas,
            bounds,
            measurePoints   // üî∫ echtes Polygon
          );

          downloadCanvas(
            masked,
            bounds.getCenter(),
            map.getZoom()
          );
        });
      });
    }, 300);
  }

  function downloadCanvas(canvas, center, zoom) {
    const link = document.createElement("a");
    link.href = canvas.toDataURL("image/png");
    const lat = center.lat.toFixed(1);
    const lng = center.lng.toFixed(1);
    link.download = `Map-Lat${lat}-Lng${lng}-Zm${zoom}.png`;
    link.click();
  }







  function focusTrip(marker, data) {
    const target = marker.getLatLng();

    // üî• Marker links platzieren
    const mapSize = map.getSize();
    const point = map.latLngToContainerPoint(target);
    point.x -= mapSize.x * 0.25; // 25% nach links

    const newCenter = map.containerPointToLatLng(point);

    map.setView(newCenter, Math.max(map.getZoom(), 5), {
      animate: true,
      duration: 0.6
    });

    renderTripPanel(data);
  }

  function renderTripPanel(data) {
    infoName.textContent = data.title;
    infoContent.innerHTML = `
      <div class="trip-text">${data.text || "‚Äî"}</div>
      ${data.images.map(img =>
        `<img src="${img}" style="width:100%;border-radius:8px;margin-top:6px;">`
      ).join("")}
    `;

    infoPanel.style.display = "flex";
    infoName.style.display = "flex";
    infoContent.style.display = "block";
  }


  function spawnTripMarker(id, data) {
    const marker = L.marker([data.lat, data.lng]).addTo(map);

    marker.on("click", () => {
      focusTrip(marker, data);
    });

    tripMarkers.set(id, marker);
  }

  map.on("popupopen", (e) => {
    const popupEl = e.popup.getElement();
    if (!popupEl) return;

    const saveBtn = popupEl.querySelector('[id^="save-"]');
    const cancelBtn = popupEl.querySelector('[id^="cancel-"]');

    if (!saveBtn || !cancelBtn) return;

    const id = saveBtn.id.replace("save-", "");

    saveBtn.onclick = async () => {
      await saveTripFromPopup(id, popupEl, e.popup._source);
    };

    cancelBtn.onclick = () => {
      map.removeLayer(e.popup._source);
    };
  });


  function handleTripClick(e) {
    if (!tripModeEnabled) return;

    const tempMarker = L.marker(e.latlng).addTo(map);

    tempMarker.bindPopup(renderTripCreatePopup(), {
      closeOnClick: false,
      autoClose: false
    }).openPopup();
  }

  function renderTripCreatePopup() {
    const id = crypto.randomUUID();

    return `
      <div class="trip-form">
        <input id="trip-title-${id}" placeholder="Titel">
        <textarea id="trip-text-${id}" placeholder="Beschreibung"></textarea>
        <input id="trip-images-${id}" type="file" multiple accept="image/*">

        <button id="save-${id}">üíæ</button>
        <button id="cancel-${id}">‚úñ</button>
      </div>
    `;
  }



  async function loadTrips() {
    const res = await fetch("./trips/trips.json");
    const tripFolders = await res.json();

    for (const folder of tripFolders) {
      const infoRes = await fetch(`./trips/${folder}/info.json`);
      const data = await infoRes.json();

      // Bilder automatisch anhand Dateinamen laden
      const images = [];
      let i = 1;

      while (true) {
        const imgUrl = `./trips/${folder}/${i}.jpg`;

        try {
          const test = await fetch(imgUrl, { method: "HEAD" });
          if (!test.ok) break;
          images.push(imgUrl);
          i++;
        } catch {
          break;
        }
      }

      spawnTripMarker(folder, {
        ...data,
        images
      });
    }
  }


  loadTrips();

  async function saveTripFromPopup(id, popupEl, marker) {
    const title = popupEl.querySelector(`#trip-title-${id}`).value.trim();
    const text = popupEl.querySelector(`#trip-text-${id}`).value.trim();
    const files = popupEl.querySelector(`#trip-images-${id}`).files;

    if (!title) {
      alert("Titel fehlt");
      return;
    }

    // ‚ö†Ô∏è vorerst: keine Uploads, nur Platzhalter
    const images = [];

    const latlng = marker.getLatLng();

    const data = {
      lat: latlng.lat,
      lng: latlng.lng,
      title,
      text,
      images
    };

    await set(ref(db, `trips/${id}`), data);

    map.removeLayer(marker);
    spawnTripMarker(id, data);
  }


</script>

</body>
</html>
