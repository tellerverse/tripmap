<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>tripmap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="./style.css">
</head>
<body>
<div id="tripOverlay" class="trip-overlay" style="display:none;">
  <button id="closeOverlay">âœ–</button>
  <canvas id="tripCanvas"></canvas>

  <div class="trip-tools">
    <button id="addImage">ğŸ–¼ï¸</button>
    <button id="addText">ğŸ“</button>
    <button id="addRect">â¬›</button>
    <button id="saveCanvas">ğŸ’¾</button>
  </div>
</div>
<div class="controls options">
  <div class="function"><button id="myZoomIn">â•</button><span>Zoom In</span></div>
  <div class="function"><button id="myZoomOut">â–</button><span>Zoom Out</span></div>
  <div class="function"><button id="myScreenshot">ğŸ“¸</button><span>Snapshot</span></div>
  <div class="function"><button id="editButton">ğŸ“¸</button><span>EDIT</span></div>
</div>

<div class="controls pencil">
  <div class="function"><button data-mode="country" class="active">ğŸ–±ï¸</button></div>
  <div class="function"><button data-mode="distance">âœˆï¸</button></div>
  <div class="function"><button data-mode="trip">ğŸ“</button></div>
</div>
<div id="infoPanel">
  <div id="infoName">Click somewher...</div>
  <div id="infoContent">Click on a country to see more information here.</div>
</div>
<div id="infoRest"></div>
<div id="teleportPanel" class="teleport-panel">
  <input id="teleLat" type="number" min="-90" max="90" placeholder="Lat">
  <input id="teleLng" type="number" min="-180" max="180" placeholder="Lon">
  <input id="teleZoom" type="number" min="1" max="19" placeholder="Zoom">
</div>
<div id="map"></div>
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fabric@5.3.0/dist/fabric.min.js"></script>


<script type="module">
  import { ref, get, set } from "https://www.gstatic.com/firebasejs/10.3.0/firebase-database.js";
  import { db } from "./database.js";

  const map = L.map("map", { zoomControl:false }).setView([20, 0], 3);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom:19, attribution:"Â© OpenStreetMap contributors" }).addTo(map);
  // L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",{attribution: "Â© OpenStreetMap Â© CARTO"}).addTo(map);
  const infoContent = document.getElementById('infoContent');
  const infoName = document.getElementById('infoName');
  const infoRest = document.getElementById('infoRest');

  let comparisonCentroid;
  let comparisonLayer = null;
  let isDraggingComparison = false;
  let geojsonLayer;
  let selectedCountryPolygon = null;
  let selectedCountryName = null;
  let selectedCountryLayer = null;
  const BLINK_INTERVAL_MS = 100;
  const MIN_AREA_KM2 = 3_000_000;
  let blinkingLayers = [];
  let allCountriesWithArea = [];
  let activeMode = "country";
  let comparisonBaseFeature = null;
  let tripModeEnabled = false;
  let tripMarkers = new Map();
  let selectedTripMarker = null;

  const pencilButtons = document.querySelectorAll(".controls.pencil button");

  pencilButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      pencilButtons.forEach(b => b.classList.remove("active"));
      btn.classList.add("active");

      activeMode = btn.dataset.mode;
      
      resetModes();
    });
  });

  function resetModes() {
    measurePoints = [];
    clearMeasurement();
    despawnComparison();
    updateScreenshotButton();
    tripAddBtn.style.display = activeMode === "trip" ? "inline-block" : "none";
    tripModeEnabled = false;
    tripAddBtn.classList.remove("active");
    if (selectedCountryLayer) {
      removeClass(selectedCountryLayer, "country-selected");
      removeClass(selectedCountryLayer, "country-hover");

      selectedCountryLayer = null;
      selectedCountryPolygon = null;
      selectedCountryName = null;

      infoContent.style.display = "none";
      infoName.style.display = "none";
    }

    map.getContainer().classList.toggle(
      "flight-mode",
      activeMode === "distance"
    );

    if (activeMode === "country") {
      startAreaBasedBlinking();
    } else {
      stopAreaBasedBlinking();
    }
  }

  map.on("click", (e) => {
    switch (activeMode) {
      case "distance":
        handleDistanceClick(e);
        break;

      case "trip":
        handleTripClick(e);
        break;

      case "country":
      default:
        break;
    }
  });

  map.on("contextmenu", () => {
    if (activeMode === "distance") {
      clearMeasurement(true);
    }
  });

  function addClass(layer, className) {
    const el = layer.getElement();
    if (el) el.classList.add(className);
  }

  function removeClass(layer, className) {
    const el = layer.getElement();
    if (el) el.classList.remove(className);
  }

  let blinkInterval = null;

  function startAreaBasedBlinking() {
    if (blinkInterval) return;

    blinkInterval = setInterval(() => {
      if (activeMode !== "country") return;
      if (selectedCountryLayer) return;

      blinkingLayers.forEach(l => removeClass(l, "country-blink"));
      blinkingLayers = [];

      let totalArea = 0;
      const shuffled = [...allCountriesWithArea].sort(() => Math.random() - 0.5);

      for (const { layer, areaKm2 } of shuffled) {
        addClass(layer, "country-blink");
        blinkingLayers.push(layer);
        totalArea += areaKm2;
        if (totalArea >= MIN_AREA_KM2) break;
      }
    }, BLINK_INTERVAL_MS);
  }

  function stopAreaBasedBlinking() {
    if (!blinkInterval) return;

    clearInterval(blinkInterval);
    blinkInterval = null;

    blinkingLayers.forEach(l => removeClass(l, "country-blink"));
    blinkingLayers = [];
  }

  function onEachCountry(feature, layer) {
    layer.on({
      mouseover: () => {
        if (activeMode !== "country") return;
        if (layer !== selectedCountryLayer) {
          addClass(layer, "country-hover");
        }
      },

      mouseout: () => {
        if (layer !== selectedCountryLayer) {
          removeClass(layer, "country-hover");
        }
      },

      click: () => {
        if (activeMode !== "country") return;
        if (layer === selectedCountryLayer) {
          removeClass(layer, "country-selected");
          selectedCountryLayer = null;
          selectedCountryPolygon = null;
          selectedCountryName = null;
          despawnComparison();
          infoContent.style.display = "none";
          infoName.style.display = "none";
          return;
        }

        if (selectedCountryLayer) {
          removeClass(selectedCountryLayer, "country-selected");
        }

        selectedCountryLayer = layer;
        selectedCountryPolygon = feature.geometry;
        selectedCountryName = feature.properties.ADMIN;
        createComparisonCopy(feature, layer.getBounds().getCenter());

        addClass(layer, "country-selected");
        removeClass(layer, "country-hover");
        for (const blinkLayer of blinkingLayers) {
          removeClass(blinkLayer, "country-blink");
        }
        blinkingLayers = [];
        infoName.textContent = selectedCountryName;
        infoContent.style.display = "flex";
        infoName.style.display = "flex";
        
        fetchAIIntro(selectedCountryName);
        fetchRestCountries(selectedCountryName);
      }
    });
  }

  function createComparisonCopy(feature) {
    comparisonBaseFeature = turf.clone(feature);
    comparisonCentroid = turf.centroid(feature);

    // ğŸ”¥ Startposition = Original-Land
    const [lng, lat] = comparisonCentroid.geometry.coordinates;

    renderComparison(comparisonTargetLatLng);
    enableComparisonDragging();
  }

  function renderComparison(targetLatLng) {
    const sourceCenter = comparisonCentroid.geometry.coordinates;
    const sourceLatLng = L.latLng(sourceCenter[1], sourceCenter[0]);

    const p0 = project(sourceLatLng);
    const p1 = project(targetLatLng);

    const scale =
      Math.cos(sourceLatLng.lat * Math.PI / 180) /
      Math.cos(targetLatLng.lat * Math.PI / 180);

    const dx = p1.x - p0.x;
    const dy = p1.y - p0.y;

    const moved = turf.clone(comparisonBaseFeature);

    turf.coordEach(moved, coord => {
      const latlng = L.latLng(coord[1], coord[0]);
      const p = project(latlng);

      const scaled = L.point(
        p0.x + (p.x - p0.x) * scale + dx,
        p0.y + (p.y - p0.y) * scale + dy
      );

      const ll = unproject(scaled);
      coord[0] = ll.lng;
      coord[1] = ll.lat;
    });

    if (comparisonLayer) map.removeLayer(comparisonLayer);
    comparisonLayer = L.geoJSON(moved, {
      className: "country comparison",
      style: {
        color: "#00ffff",
        weight: 2,
        fillOpacity: 0.15
      }
    }).addTo(map);
    comparisonLayer.on("mousedown", e => {
      L.DomEvent.stopPropagation(e);
      L.DomEvent.preventDefault(e);

      isDraggingComparison = true;
      map.dragging.disable();
    });
  }

  function project(latlng) {
    return map.options.crs.project(latlng);
  }

  function unproject(point) {
    return map.options.crs.unproject(point);
  }

  function despawnComparison() {
    if (comparisonLayer) {
      map.removeLayer(comparisonLayer);
      comparisonLayer = null;
    }

    comparisonBaseFeature = null;
    comparisonCentroid = null;
    isDraggingComparison = false;

    map.dragging.enable();
  }

  function enableComparisonDragging() {
    if (!comparisonLayer) return;

    map.on("mousedown", e => {
      if (isDraggingComparison) {
        L.DomEvent.stopPropagation(e);
        map.dragging.disable();
      }
    });

    map.on("mousemove", e => {
      if (!isDraggingComparison || !comparisonBaseFeature) return;

      renderComparison(comparisonTargetLatLng);
    });

    map.on("mouseup", () => {
      isDraggingComparison = false;
      map.dragging.enable();
      // ğŸ¯ Zielposition bleibt gespeichert
    });
  }

  fetch("https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_10m_admin_0_countries.geojson")
  .then(res => res.json())
  .then(data => {
    geojsonLayer = L.geoJSON(data, {
      className: "country",
      onEachFeature: onEachCountry
    }).addTo(map);

    // FlÃ¤che einmal berechnen
    geojsonLayer.eachLayer(layer => {
      const feature = layer.feature;
      const areaKm2 = turf.area(feature) / 1_000_000;
      allCountriesWithArea.push({ layer, areaKm2 });
    });

    startAreaBasedBlinking();
  });

  async function fetchAIIntro(countryName) {
    const res = await fetch("/api/getIntro", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ countryName })
    });

    if (!res.ok) {
      infoContent.textContent = "AI unavailable, loading wikipediaâ€¦";
      setTimeout(() => {
        fetchWikiIntro(countryName);
      }, 2000);
      return;
    }

    const data = await res.json();
    infoContent.textContent = data.text;
  }

  const countryToWiki = {
    Germany: "Germany",
    France: "France",
    Spain: "Spain"
  };

  async function fetchWikiIntro(countryName) {
    infoContent.textContent = `AI unavailable, loading wikipediaâ€¦`;
    try {
      const wikiTitle = countryToWiki[countryName] || countryName;
      const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(wikiTitle)}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error("Wikipedia-Eintrag nicht gefunden.");
      const data = await res.json();
      infoContent.textContent = data.extract || "Keine Informationen verfÃ¼gbar.";
    } catch(e) {
      infoContent.textContent = `Fehler beim Laden von ${countryName}.`;
      console.error(e);
    }
  }

  async function fetchRestCountries(countryName) {
    infoContent.innerHTML = "Loading country dataâ€¦";
    const res = await fetch(`https://restcountries.com/v3.1/name/${encodeURIComponent(countryName)}?fullText=true`);
    if (!res.ok) return;
    const [country] = await res.json();
    renderCountryAttributes(country);
  }

  function renderCountryAttributes(country) {
    // infoContent.innerHTML = "";
    const keysIWant = [
      "population",
      "timezones",
      "flag",
      "languages",
      "capital",
      "currencies"
    ];
    let i = 0;
    for (const [key, value] of Object.entries(country)) {
      // if (i++ >= 3) break;
      if (!keysIWant.includes(key)) continue;
      const content = document.createElement("div");
      content.classList.add("restInfoTile", "scroll-text");
      content.textContent = formatValue(value);
      infoRest.appendChild(content);
    }
  }

  function formatValue(value) {
    if (value == null) return "â€”";
    if (Array.isArray(value)) {
      return value.map(v => formatValue(v)).join(", ");
    }
    if (typeof value === "object") {
      return Object.values(value)
        .map(v => formatValue(v))
        .join(", ");
    }
    return value.toString();
  }

  document.getElementById("myZoomIn").addEventListener("click", () => map.zoomIn());
  document.getElementById("myZoomOut").addEventListener("click", () => map.zoomOut());
  const tripAddBtn = document.createElement("button");
  tripAddBtn.textContent = "â• Trip";
  tripAddBtn.id = "addTripMarker";
  tripAddBtn.style.display = "none";
  document.querySelector(".controls.options").appendChild(tripAddBtn);

  tripAddBtn.onclick = () => {
    tripModeEnabled = !tripModeEnabled;
    tripAddBtn.classList.toggle("active", tripModeEnabled);
  };

  let measurePoints = [];
  let measureLayer = null;
  let measureLabels = [];
  let measureHandles = [];

  function handleDistanceClick(e) {
    measurePoints.push(e.latlng);
    createHandle(e.latlng, measurePoints.length - 1);
    redrawMeasurement();
  }

  function redrawMeasurement() {
    clearMeasurement(false);
    if (measurePoints.length < 2) return;
    if (measurePoints.length === 2) {
      measureLayer = L.polyline(measurePoints, {
        color: "white",
        weight: 2
      }).addTo(map);
      addEdgeLabels(measurePoints);
    } else {
      measureLayer = L.polygon(measurePoints, {
        color: "white",
        fillOpacity: 0.2
      }).addTo(map);
      addEdgeLabels(measurePoints, true);
      addAreaLabel(measurePoints);
    }
  }


  function addEdgeLabels(points, closed = false) {
    const pts = closed ? [...points, points[0]] : points;
    for (let i = 0; i < pts.length - 1; i++) {
      const a = pts[i];
      const b = pts[i + 1];

      const len = turf.distance(
        [a.lng, a.lat],
        [b.lng, b.lat],
        { units: "kilometers" }
      );
      const mid = L.latLng(
        (a.lat + b.lat) / 2,
        (a.lng + b.lng) / 2
      );
      const label = L.marker(mid, {
        icon: L.divIcon({
          className: "",
          html: `<div class="edge-label">${len.toFixed(2)} km</div>`
          // iconAnchor: [0, 0]

        })
      }).addTo(map);
      measureLabels.push(label);
    }
  }

  function addAreaLabel(points) {
    const coords = [...points, points[0]].map(p => [p.lng, p.lat]);
    const area = turf.area(turf.polygon([coords])) / 1_000_000;
    const center = turf.centroid(turf.polygon([coords])).geometry.coordinates;
    const label = L.marker([center[1], center[0]], {
      icon: L.divIcon({
        className: "",
        html: `<div class="area-label">${area.toFixed(2)} kmÂ²</div>`
      })
    }).addTo(map);
    measureLabels.push(label);
  }

  function clearMeasurement(resetPoints = true) {
    if (measureLayer) map.removeLayer(measureLayer);
    measureLabels.forEach(l => map.removeLayer(l));
    measureLayer = null;
    measureLabels = [];
    if (resetPoints) {
      measureHandles.forEach(h => map.removeLayer(h));
      measureHandles = [];
      measurePoints = [];
    }
  }

  function createHandle(latlng, index) {
    const handle = L.marker(latlng, {
      draggable: true,
      icon: L.divIcon({
        className: "measure-handle",
        iconSize: [12, 12]
      })
    }).addTo(map);
    handle.on("dragstart", () => {map.dragging.disable();});
    handle.on("drag", (e) => {
      measurePoints[index] = e.target.getLatLng();
      redrawMeasurement();
    });
    handle.on("dragend", () => {map.dragging.enable();});
    measureHandles.push(handle);
  }

  const teleLat = document.getElementById("teleLat");
  const teleLng = document.getElementById("teleLng");
  const teleZoom = document.getElementById("teleZoom");
  teleLat.addEventListener("input", applyTeleportInputs);
  teleLng.addEventListener("input", applyTeleportInputs);
  teleZoom.addEventListener("input", applyTeleportInputs);

  function applyTeleportInputs() {
    const lat = parseFloat(teleLat.value);
    const lng = parseFloat(teleLng.value);
    const zoom = parseInt(teleZoom.value);
    if (Number.isNaN(lat) || Number.isNaN(lng) || Number.isNaN(zoom)) return;
    map.setView([lat, lng], zoom, { animate: true });
  }

  function updateTeleportInputs() {
    const center = map.getCenter();
    const zoom = map.getZoom();

    teleLat.value = center.lat.toFixed(6);
    teleLng.value = center.lng.toFixed(6);
    teleZoom.value = zoom;
  }

  updateTeleportInputs();
  map.on("moveend zoomend", updateTeleportInputs);

  function polygonToCanvasPath(ctx, points, offset) {
    ctx.beginPath();
    points.forEach((p, i) => {
      const pt = map.latLngToContainerPoint(p);
      const x = pt.x - offset.x;
      const y = pt.y - offset.y;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.closePath();
  }

  function boundsToPixelRect(bounds) {
    const nw = map.latLngToContainerPoint(bounds.getNorthWest());
    const se = map.latLngToContainerPoint(bounds.getSouthEast());
    return {
      x: Math.round(nw.x),
      y: Math.round(nw.y),
      w: Math.round(se.x - nw.x),
      h: Math.round(se.y - nw.y)
    };
  }
  
  function cropAndMaskCanvas(srcCanvas, bounds, polygonLatLngs) {
    const rect = boundsToPixelRect(bounds);

    const dst = document.createElement("canvas");
    dst.width = rect.w;
    dst.height = rect.h;
    const ctx = dst.getContext("2d");

    if (polygonLatLngs.length >= 3) {
      polygonToCanvasPath(ctx, polygonLatLngs, rect);
      ctx.clip();
    }
    ctx.drawImage(
      srcCanvas,
      rect.x, rect.y, rect.w, rect.h,
      0, 0, rect.w, rect.h
    );
    return dst;
  }

  function withoutMeasurementLayers(fn) {
    const layers = [...measureLabels, ...measureHandles];
    layers.forEach(l => map.removeLayer(l));
    fn();
    layers.forEach(l => map.addLayer(l));
  }

  const screenshotButton = document.getElementById("myScreenshot");

  function updateScreenshotButton() {
    screenshotButton.style.display = activeMode === "distance" ? "inline-block" : "none";
  }

  updateScreenshotButton();
  screenshotButton.addEventListener("click", takeMapSnapshot);

  function takeMapSnapshot() {
    if (!measurePoints || measurePoints.length === 0) {
      leafletImage(map, (err, canvas) => {
        if (err) return console.error(err);
        downloadCanvas(canvas, map.getCenter(), map.getZoom());
      });
      return;
    }

    if (measurePoints.length === 1) {
      const center = measurePoints[0];
      const zoom = map.getZoom();

      map.setView(center, zoom, { animate: false });

      setTimeout(() => {
        withoutMeasurementLayers(() => {
          leafletImage(map, (err, canvas) => {
            if (err) return console.error(err);
            downloadCanvas(canvas, center, zoom);
          });
        });
      }, 300);
      return;
    }

    const lats = measurePoints.map(p => p.lat);
    const lngs = measurePoints.map(p => p.lng);
    const southWest = L.latLng(Math.min(...lats), Math.min(...lngs));
    const northEast = L.latLng(Math.max(...lats), Math.max(...lngs));
    const bounds = L.latLngBounds(
      [Math.min(...lats), Math.min(...lngs)],
      [Math.max(...lats), Math.max(...lngs)]
    );
    map.fitBounds(bounds, { padding: [0, 0] });
    setTimeout(() => {
      withoutMeasurementLayers(() => {
        leafletImage(map, (err, fullCanvas) => {
          if (err) return console.error(err);

          const masked = cropAndMaskCanvas(
            fullCanvas,
            bounds,
            measurePoints   // ğŸ”º echtes Polygon
          );

          downloadCanvas(
            masked,
            bounds.getCenter(),
            map.getZoom()
          );
        });
      });
    }, 300);
  }

  function downloadCanvas(canvas, center, zoom) {
    const link = document.createElement("a");
    link.href = canvas.toDataURL("image/png");
    const lat = center.lat.toFixed(1);
    const lng = center.lng.toFixed(1);
    link.download = `Map-Lat${lat}-Lng${lng}-Zm${zoom}.png`;
    link.click();
  }


























  const TRIP_IMAGE_BASE = "/images/trips/";
  let nextImageIndex = 1;


  function spawnTripMarker(id, data) {
    const marker = L.marker([data.lat, data.lng]).addTo(map);

    marker.on("click", async () => {
      const snap = await get(ref(db, `trips/${id}`));
      openTripCanvas(id, snap.val());
    });

    tripMarkers.set(id, marker);
  }

  map.on("popupopen", (e) => {
    const popupEl = e.popup.getElement();
    if (!popupEl) return;

    const saveBtn = popupEl.querySelector('[id^="save-"]');
    const cancelBtn = popupEl.querySelector('[id^="cancel-"]');

    if (!saveBtn || !cancelBtn) return;

    const id = saveBtn.id.replace("save-", "");

    saveBtn.onclick = async () => {
      await saveTripFromPopup(id, popupEl, e.popup._source);
    };

    cancelBtn.onclick = () => {
      map.removeLayer(e.popup._source);
    };
  });


  function handleTripClick(e) {
    if (!tripModeEnabled) return;

    const tempMarker = L.marker(e.latlng).addTo(map);

    tempMarker.bindPopup(renderTripCreatePopup(), {
      closeOnClick: false,
      autoClose: false
    }).openPopup();
  }

  function renderTripCreatePopup() {
    const id = crypto.randomUUID();

    return `
      <div class="trip-form">
        <input id="trip-title-${id}" placeholder="Titel">
        <textarea id="trip-text-${id}" placeholder="Beschreibung"></textarea>
        <input id="trip-images-${id}" multiple accept="image/*">

        <button id="save-${id}">ğŸ’¾</button>
        <button id="cancel-${id}">âœ–</button>
      </div>
    `;
  }


  async function saveTripFromPopup(id, popupEl, marker) {
    const title = popupEl.querySelector(`#trip-title-${id}`).value.trim();
    const text = popupEl.querySelector(`#trip-text-${id}`).value.trim();
    const files = popupEl.querySelector(`#trip-images-${id}`).files;

    if (!title) {
      alert("Titel fehlt");
      return;
    }


    const latlng = marker.getLatLng();

    const data = {
      lat: latlng.lat,
      lng: latlng.lng,
      title,
      text
    };

    await set(ref(db, `trips/${id}`), {
      ...data,
      canvas: null
    });


    map.removeLayer(marker);
    spawnTripMarker(id, data);
  }

  const overlay = document.getElementById("tripOverlay");
  const closeOverlay = document.getElementById("closeOverlay");

  const addImageBtn = document.getElementById("addImage");
  const addTextBtn = document.getElementById("addText");
  const addRectBtn = document.getElementById("addRect");
  const saveCanvasBtn = document.getElementById("saveCanvas");

  // initial ausblenden
  [addImageBtn, addTextBtn, addRectBtn, saveCanvasBtn].forEach(btn => btn.style.display = "none");


  // schlieÃŸen
  closeOverlay.onclick = () => {
    overlay.style.display = "none";
  };

  let tripCanvas;
  let currentTripId = null;

  function openTripCanvas(tripId, data) {
    const canvasEl = document.getElementById("tripCanvas");

    if (tripCanvas) {
      tripCanvas.dispose();
    }

    tripCanvas = new fabric.Canvas(canvasEl, {
      width: 1200,
      height: 800,
      backgroundColor: "#111"
    });

    if (data.canvas) {
      tripCanvas.loadFromJSON(data.canvas, () => {

        // Bilder neu verbinden
        tripCanvas.getObjects("image").forEach(obj => {
          if (obj.tripImageIndex) {
            const url = `${TRIP_IMAGE_BASE}${obj.tripImageIndex}.png`;
            obj.setSrc(url, tripCanvas.renderAll.bind(tripCanvas));
          }
        });

        syncNextImageIndex();
        tripCanvas.renderAll();
      });
    }
    tripCanvas.getObjects().forEach(obj => {
      obj.selectable = false; // deaktiviert Verschieben, Skalieren, Drehen
      obj.evented = false;    // deaktiviert Klick-Events auf dem Objekt
    });
    tripCanvas.renderAll();


    currentTripId = tripId;
    document.getElementById("tripOverlay").style.display = "flex";
  }

  function addImage(url) {
    fabric.Image.fromURL(url, img => {
      img.set({
        left: 100,
        top: 100,
        scaleX: 0.4,
        scaleY: 0.4,
        selectable: true
      });
      tripCanvas.add(img);
    });
  }

  document.getElementById("addText").onclick = () => {
    if (!editMode) return
    const text = new fabric.Textbox("Text", {
      left: 200,
      top: 200,
      fill: "#fff",
      fontSize: 24,
      width: 300
    });
    tripCanvas.add(text);
  };

  document.getElementById("addRect").onclick = () => {
    if (!editMode) return
    const rect = new fabric.Rect({
      left: 100,
      top: 400,
      width: 200,
      height: 100,
      fill: "rgba(255,255,255,0.2)"
    });
    tripCanvas.add(rect);
  };

  async function saveTripCanvas(tripId) {
    const json = tripCanvas.toJSON(["tripImageIndex"]);
    await set(ref(db, `trips/${tripId}/canvas`), json);
  }

  document.getElementById("saveCanvas").onclick = () => {
    if (!editMode) return
    saveTripCanvas(currentTripId);
  };

  async function loadTripsFromFirebase() {
    const snap = await get(ref(db, "trips"));
    if (!snap.exists()) return;

    const trips = snap.val();
    for (const [id, data] of Object.entries(trips)) {
      spawnTripMarker(id, data);
    }
  }

  loadTripsFromFirebase();

  document.getElementById("addImage").onclick = () => {
    if (!editMode) return
    spawnNextTripImage();
  };

  function spawnNextTripImage() {
    const url = `${TRIP_IMAGE_BASE}${nextImageIndex}.png`;

    fabric.Image.fromURL(url, img => {
      img.set({
        left: 100,
        top: 100,
        scaleX: 0.4,
        scaleY: 0.4,
        selectable: true,

        // ğŸ”’ Metadaten
        tripImageIndex: nextImageIndex
      });

      tripCanvas.add(img);
      tripCanvas.setActiveObject(img);

      nextImageIndex++;
    }, { crossOrigin: "anonymous" });
  }

  document.addEventListener("keydown", e => {
    if (e.key !== "Delete") return;

    const obj = tripCanvas.getActiveObject();
    if (!obj) return;

    tripCanvas.remove(obj);
  });

  function syncNextImageIndex() {
    const used = tripCanvas
      .getObjects("image")
      .map(o => o.tripImageIndex || 0);

    nextImageIndex = used.length ? Math.max(...used) + 1 : 1;
  }
  const editButton = document.getElementById("editButton");
  editButton.textContent = "Bearbeiten freischalten";

  let editMode = false;

  editButton.onclick = async () => {
    if (editMode) return;

    const password = prompt("Passwort eingeben:");
    if (!password) return;

    const res = await fetch("/api/checkPassword", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ password })
    });

    const data = await res.json();
    if (data.ok) {
      editMode = true;
      [addImageBtn, addTextBtn, addRectBtn, saveCanvasBtn].forEach(btn => btn.style.display = "inline-block");

      alert("Bearbeitungsmodus aktiviert!");
      overlay.style.display = "flex"; // z.B. direkt Overlay freischalten
    } else {
      alert("Falsches Passwort!");
    }
  };


</script>

</body>
</html>
